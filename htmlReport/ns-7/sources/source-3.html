


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > InMemoryHistoryManager</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">ru.yandex.practicum.model</a>
</div>

<h1>Coverage Summary for Class: InMemoryHistoryManager (ru.yandex.practicum.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">InMemoryHistoryManager</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
</tr>
  <tr>
    <td class="name">InMemoryHistoryManager$CustomLinkedList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87%
  </span>
  <span class="absValue">
    (47/54)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InMemoryHistoryManager$CustomLinkedList$Node</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (63/70)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package ru.yandex.practicum.model;
&nbsp;
&nbsp;import ru.yandex.practicum.service.Task;
&nbsp;
&nbsp;import java.util.*;
&nbsp;
<b class="fc">&nbsp;public class InMemoryHistoryManager implements HistoryManager {</b>
&nbsp;    //Создавем связанный список для хранения истории просмотров.
<b class="fc">&nbsp;    private final CustomLinkedList&lt;Task&gt; history = new CustomLinkedList&lt;&gt;();</b>
&nbsp;
&nbsp;    @Override
&nbsp;    //Метод для добавления очередной просмотренной задачи в Связанный список history
&nbsp;    public void add(Task task) {
<b class="fc">&nbsp;        if (history.map.containsKey(task.getId())) {                //Если в списке уже содержится такая задача,</b>
<b class="fc">&nbsp;            remove(task.getId());                                   //удаляем предыдущую запись</b>
&nbsp;        } else
<b class="fc">&nbsp;            history.linkLast(task);                                     //и добавляем ее в конец</b>
&nbsp;        //  System.out.println(history.map.values());
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void remove(int id) {
<b class="fc">&nbsp;        if (!history.map.isEmpty()) {                //Если мапа не пустая</b>
<b class="fc">&nbsp;            history.removeNode(history.map.get(id)); //Удаляем ссылки из Связанного списка на ноду</b>
<b class="fc">&nbsp;            history.map.remove(id);                  //Также удаляем ноду из мапы</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;Task&gt; getHistory() {
<b class="fc">&nbsp;        return history.getTasks();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Кастомный LinkedList
&nbsp;     *
&nbsp;     * @param &lt;E&gt;
&nbsp;     */
<b class="fc">&nbsp;    private static class CustomLinkedList&lt;E extends Task&gt; {</b>
&nbsp;        private Node&lt;E&gt; head; //поле для головного элемента
&nbsp;        private Node&lt;E&gt; tail; //поле для хвоста
<b class="fc">&nbsp;        private int size = 0; //длина списка</b>
<b class="fc">&nbsp;        private final Map&lt;Integer, Node&lt;E&gt;&gt; map = new HashMap&lt;&gt;(); //мапа, которая в ключе хранит id задачи, а в значении узел связанного списка</b>
&nbsp;
&nbsp;        private void linkLast(E value) {
<b class="fc">&nbsp;            if (head == null) {                          //В первую очередь, проверям, пуст ли наш связанный список</b>
<b class="fc">&nbsp;                Node&lt;E&gt; currentNode = new Node&lt;&gt;(value); //Новая нода</b>
<b class="fc">&nbsp;                map.put(value.getId(), currentNode);     //Добавляем новую ноду в мапу</b>
<b class="fc">&nbsp;                head = currentNode;                      //Текущая нода - это голова списка</b>
<b class="fc">&nbsp;            } else if (size == 1) {                      //Если же в списке всего один элемент</b>
<b class="fc">&nbsp;                Node&lt;E&gt; currentNode = new Node&lt;&gt;(value); //Новая нода</b>
<b class="fc">&nbsp;                head.setNext(currentNode);               //Связываем голову с нашей новой нодой</b>
<b class="fc">&nbsp;                map.put(value.getId(), currentNode);     //Добавляем в мапу новую ноду</b>
<b class="fc">&nbsp;                currentNode.setPrev(head);               //Наша новая нода ссылается на предыдущую - голову списка</b>
<b class="fc">&nbsp;                tail = currentNode;                      //Хвост спика - новая нода</b>
<b class="fc">&nbsp;            } else {</b>
<b class="fc">&nbsp;                Node&lt;E&gt; currentNode = new Node&lt;&gt;(value); //Новая нода</b>
<b class="fc">&nbsp;                currentNode.setPrev(tail);               //Новая нода ссылается на предыдущий элемент - хвос списка</b>
<b class="fc">&nbsp;                map.put(value.getId(), currentNode);     //Добавляем в мапу новую ноду</b>
<b class="fc">&nbsp;                tail.setNext(currentNode);               //Связываем предыдущих вост с новой нодой</b>
<b class="fc">&nbsp;                tail = currentNode;                      //Теперь новая нода - хвост списка</b>
&nbsp;            }
<b class="fc">&nbsp;            ++size;                                      //увеличиваем счетчик длины списка на 1 --&gt; используем префиксный инкремент</b>
&nbsp;        }
&nbsp;
&nbsp;        private List&lt;E&gt; getTasks() {
<b class="fc">&nbsp;            if (head != null) {                             //Если список не пустой</b>
<b class="fc">&nbsp;                List&lt;E&gt; tasks = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;                Node&lt;E&gt; currentNode = head;                 //поле для хранения текущей ноды. Нужно, чтобы пробежаться по списку</b>
&nbsp;                while (true) {
<b class="fc">&nbsp;                    tasks.add(currentNode.getValue());      //добавляем значение текущей ноды</b>
<b class="fc">&nbsp;                    if (currentNode.getNext() == null)      //если следующего элемента не существует</b>
<b class="fc">&nbsp;                        break;</b>
<b class="fc">&nbsp;                    currentNode = currentNode.getNext();    //переходим к следующей ноде</b>
&nbsp;                }
<b class="fc">&nbsp;                return tasks;</b>
&nbsp;            } else
<b class="fc">&nbsp;                return null;                                //Если пустой, то возвращаем Null</b>
&nbsp;        }
&nbsp;
&nbsp;        private void removeNode(Node&lt;E&gt; value) {
<b class="fc">&nbsp;            if (size == 0)</b>
&nbsp;                return;
<b class="fc">&nbsp;            else if (size == 1) {                     //Если список пуст</b>
<b class="fc">&nbsp;                head = null;</b>
<b class="fc">&nbsp;            } else if (head == value) {             //Если нода, которую хотим удалить - голова</b>
<b class="fc">&nbsp;                if (size == 2) {                    //Если список содержит всего две ноды</b>
<b class="nc">&nbsp;                    tail.setPrev(null);             //Отвязываем голову и хвост</b>
<b class="nc">&nbsp;                    head.setNext(null);</b>
<b class="nc">&nbsp;                    head = tail;                    //голова равна хвосту</b>
<b class="nc">&nbsp;                    tail = null;                    //а хвост равен Null</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    head = head.getNext();          //голова теперь равна следующему элементу</b>
<b class="fc">&nbsp;                    head.getPrev().setNext(null);   //Убираем ссылки на ноду, которую хотим удалить</b>
<b class="fc">&nbsp;                    head.setPrev(null);</b>
&nbsp;                }
<b class="fc">&nbsp;            } else if (tail == value) {             //Если искомая нода - хвост</b>
<b class="fc">&nbsp;                if (size == 2) {                    //Делаем пости все то же самое, что и в пердыдущем случае</b>
<b class="nc">&nbsp;                    tail.setPrev(null);</b>
<b class="nc">&nbsp;                    tail = null;</b>
<b class="nc">&nbsp;                    head.setNext(null);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    tail = tail.getPrev();</b>
<b class="fc">&nbsp;                    tail.getNext().setPrev(null);</b>
<b class="fc">&nbsp;                    tail.setNext(null);</b>
&nbsp;                }
&nbsp;            } else {                                        //Во всех остальных случаях просто
<b class="fc">&nbsp;                value.getPrev().setNext(value.getNext());   //переписываем ссылки на предыдущую и следующую ноду</b>
<b class="fc">&nbsp;                value.getNext().setPrev(value.getPrev());</b>
<b class="fc">&nbsp;                value.setNext(null);                        //и отвязываем нашу текующую ноду</b>
<b class="fc">&nbsp;                value.setPrev(null);</b>
&nbsp;            }
<b class="fc">&nbsp;            --size;                                             //Уменьшаем длину списка на 1 --&gt; используем префиксный декремент</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        /**
&nbsp;         * Класс Node&lt;E&gt; для элеменотв узла.
&nbsp;         * * @param &lt;E&gt;
&nbsp;         */
&nbsp;        private static class Node&lt;E&gt; {
&nbsp;            private final E value;                      //для данных внутри элемента
&nbsp;            private Node&lt;E&gt; prev;                       //поле для ссылки на предыдущий элемент
&nbsp;            private Node&lt;E&gt; next;                       //поле для ссылки на следующий элемент
&nbsp;
<b class="fc">&nbsp;            private Node(E task) {</b>
<b class="fc">&nbsp;                this.value = task;</b>
&nbsp;            }
&nbsp;
&nbsp;            public E getValue() {
<b class="fc">&nbsp;                return value;</b>
&nbsp;            }
&nbsp;
&nbsp;            public Node&lt;E&gt; getPrev() {
<b class="fc">&nbsp;                return prev;</b>
&nbsp;            }
&nbsp;
&nbsp;            public void setPrev(Node&lt;E&gt; prev) {
<b class="fc">&nbsp;                this.prev = prev;</b>
&nbsp;            }
&nbsp;
&nbsp;            public Node&lt;E&gt; getNext() {
<b class="fc">&nbsp;                return next;</b>
&nbsp;            }
&nbsp;
&nbsp;            public void setNext(Node&lt;E&gt; next) {
<b class="fc">&nbsp;                this.next = next;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-03-14 22:21</div>
</div>
</body>
</html>
