


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > HttpTaskServer</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">ru.yandex.practicum.http.server</a>
</div>

<h1>Coverage Summary for Class: HttpTaskServer (ru.yandex.practicum.http.server)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">HttpTaskServer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    52,9%
  </span>
  <span class="absValue">
    (9/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18,2%
  </span>
  <span class="absValue">
    (26/143)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package ru.yandex.practicum.http.server;
&nbsp;
&nbsp;import com.google.gson.Gson;
&nbsp;import com.google.gson.GsonBuilder;
&nbsp;import com.sun.net.httpserver.HttpExchange;
&nbsp;import com.sun.net.httpserver.HttpServer;
&nbsp;import ru.yandex.practicum.http.adapters.LocalDateTimeAdapter;
&nbsp;import ru.yandex.practicum.http.gson.deserialize.DurationJsonDeserializer;
&nbsp;import ru.yandex.practicum.http.gson.deserialize.EpicJsonDeserializer;
&nbsp;import ru.yandex.practicum.http.gson.deserialize.SubtaskJsonDeserializer;
&nbsp;import ru.yandex.practicum.model.FileBackedTasksManager;
&nbsp;import ru.yandex.practicum.service.Epic;
&nbsp;import ru.yandex.practicum.service.Subtask;
&nbsp;import ru.yandex.practicum.service.Task;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.net.InetSocketAddress;
&nbsp;import java.time.Duration;
&nbsp;import java.time.LocalDateTime;
&nbsp;
&nbsp;import static java.nio.charset.StandardCharsets.UTF_8;
&nbsp;
&nbsp;/**
&nbsp; * Содержание класса (чтоб было проще ориентироваться):
&nbsp; * метод runServer() - для запуска сервера
&nbsp; * метод stopServer() - для остановки сервера
&nbsp; * метод workingOnSimpleTasks() - для обработки GET, POST, DELETE запросов простых задач
&nbsp; * метод workingOnEpics() -  для обработки GET, POST, DELETE запросов эпиков
&nbsp; * метод workingOnSubtasks() - для обработки GET, POST, DELETE запросов подзадач
&nbsp; * метод workWithAllSubtasksOfEpic() - для получения всех подзадач определенного эпика (GET запрос)
&nbsp; * метод getAllTasks() - для получения всех задач (подзадач) в порядке приоритета (getPrioritizedTasks()) (GET запрос)
&nbsp; * метод workingWithHistory() - для получения истории задач (GET запрос)
&nbsp; * метод getValueOfId(String infOfId) - для получения id задачи из URI
&nbsp; * метод printResponse(String response, HttpExchange httpExchange) - метод для формирования ответа сервера
&nbsp; */
&nbsp;//Сначала добавьте в проект библиотеку Gson для работы с JSON.
&nbsp;//Добавьте в него реализацию FileBackedTaskManager, которую можно получить из утилитного класса Managers.
&nbsp;// После этого можно реализовать маппинг запросов на методы интерфейса TaskManager.
&nbsp;public class HttpTaskServer extends FileBackedTasksManager {
&nbsp;    //Далее создайте класс HttpTaskServer, который будет слушать порт 8080 и принимать запросы.
&nbsp;    private static final int PORT = 8090;
&nbsp;    private HttpServer server;
&nbsp;    private static final String PATH_FILE = &quot;src/FileTest.csv&quot;;
&nbsp;
<b class="fc">&nbsp;    private final Gson gson = new GsonBuilder()</b>
<b class="fc">&nbsp;            .registerTypeAdapter(Subtask.class, new SubtaskJsonDeserializer())</b>
<b class="fc">&nbsp;            .registerTypeAdapter(Epic.class, new EpicJsonDeserializer())</b>
<b class="fc">&nbsp;            .registerTypeAdapter(Duration.class, new DurationJsonDeserializer())</b>
<b class="fc">&nbsp;            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())</b>
<b class="fc">&nbsp;            .create();</b>
&nbsp;
&nbsp;    public HttpTaskServer() {
<b class="fc">&nbsp;        super(PATH_FILE);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void runServer() {
&nbsp;        try { // Unhandled exception: java.io.IOException
<b class="fc">&nbsp;            server = HttpServer.create(); // создали веб-сервер</b>
<b class="fc">&nbsp;            server.bind(new InetSocketAddress(PORT), 0); // привязали его к порту</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            e.getMessage();</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        workingOnSimpleTasks();</b>
<b class="fc">&nbsp;        workingOnEpics();</b>
<b class="fc">&nbsp;        workingOnSubtasks();</b>
<b class="fc">&nbsp;        workWithAllSubtasksOfEpic();</b>
<b class="fc">&nbsp;        workingWithHistory();</b>
<b class="fc">&nbsp;        getAllTasks();</b>
<b class="fc">&nbsp;        server.start(); // запускаем сервер</b>
<b class="fc">&nbsp;        System.out.println(&quot;HTTP-сервер запущен на &quot; + PORT + &quot; порту!&quot;);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public void stopServer() {
<b class="fc">&nbsp;        System.out.println(&quot;Завершение работы сервера на порту &quot; + PORT);</b>
<b class="fc">&nbsp;        server.stop(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    // API должен работать так, чтобы все запросы по пути /tasks/&lt;ресурсы&gt; приходили в интерфейс TaskManager.
&nbsp;    // Путь для обычных задач — /tasks/task, для подзадач — /tasks/subtask, для эпиков — /tasks/epic.
&nbsp;    // Получить все задачи сразу можно будет по пути /tasks/, а получить историю задач по пути /tasks/history.
&nbsp;    private void workingOnSimpleTasks() {
<b class="fc">&nbsp;        server.createContext(&quot;/tasks/task&quot;, (HttpExchange httpExchange) -&gt; {////Путь для обычных задач — /tasks/task</b>
<b class="nc">&nbsp;            String method = httpExchange.getRequestMethod(); //</b>
<b class="nc">&nbsp;            String response = null;</b>
<b class="nc">&nbsp;            String taskIdInfo = null;</b>
<b class="nc">&nbsp;            switch (method) {</b>
&nbsp;                case &quot;GET&quot;: //Для получения данных должны быть GET-запросы.
&nbsp;                    /**
&nbsp;                     * Функция getRawQuery () является частью класса URI.
&nbsp;                     * Функция getRawQuery () возвращает необработанный запрос указанного URI.
&nbsp;                     * Эта функция возвращает точное значение запроса без декодирования последовательности
&nbsp;                     * экранированных октетов, если таковые имеются.
&nbsp;                     */
&nbsp;                    //Еще был следующий вариант:
&nbsp;                    //Так как URI имеет следующий вид: (&quot;http://localhost:8080/tasks/task/?id=1&quot;),
&nbsp;                    //Сохранить его в String и засплитить по точке String[] url = ... .split(&quot;\\.&quot;);
&nbsp;                    //А потом взять последнюю часть получившегося массив: String id = url[utl.length -1]
&nbsp;                    // и запарсить в переменную int;
<b class="nc">&nbsp;                    taskIdInfo = httpExchange.getRequestURI().getRawQuery();</b>
&nbsp;                    // System.out.println(taskIdInfo);
<b class="nc">&nbsp;                    if (taskIdInfo != null) {</b>
<b class="nc">&nbsp;                        int taskId = getValueOfId(taskIdInfo);</b>
<b class="nc">&nbsp;                        response = getSimpleTaskById(taskId).toString();</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        getAllSimpleTasks().toString();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    printResponse(response, httpExchange);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case &quot;POST&quot;: //Для создания и изменения — POST-запросы.
&nbsp;                    //Так как метод getRequestBody() возвращает InputStream, входящий поток необходимо обработать.
&nbsp;                    // Можно, например, считать из него массив байтов методом inputStream.readAllBytes(),
&nbsp;                    // а затем с помощью конструктора String сконвертировать в строковый тип
<b class="nc">&nbsp;                    InputStream inputStream = httpExchange.getRequestBody();</b>
<b class="nc">&nbsp;                    String jsonString = new String(inputStream.readAllBytes(), UTF_8);  //Конвертирую поток байтов в String</b>
<b class="nc">&nbsp;                    Task newTask = gson.fromJson(jsonString, Task.class);</b>
<b class="nc">&nbsp;                    if (!simpleTasks.containsKey(newTask.getId())) {</b>
<b class="nc">&nbsp;                        addSimpleTask(newTask);</b>
<b class="nc">&nbsp;                        response = String.format(&quot;Задача под id = %d успешно создана&quot;, newTask.getId());</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        updateSimpleTaskById(newTask.getId(), newTask);</b>
<b class="nc">&nbsp;                        response = String.format(&quot;Задача под id = %d успешно обновлена&quot;, newTask.getId());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    printResponse(response, httpExchange);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case &quot;DELETE&quot;: // Для удаления — DELETE-запросы.
<b class="nc">&nbsp;                    taskIdInfo = httpExchange.getRequestURI().getRawQuery();</b>
<b class="nc">&nbsp;                    if (taskIdInfo != null) {</b>
<b class="nc">&nbsp;                        int simpleTAskId = getValueOfId(taskIdInfo);</b>
<b class="nc">&nbsp;                        removeSimbletaskById(simpleTAskId);</b>
<b class="nc">&nbsp;                        response = String.format(&quot;Задача под id = %d удалена&quot;, simpleTAskId);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    printResponse(response, httpExchange);</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private void workingOnEpics() {
<b class="fc">&nbsp;        server.createContext(&quot;/tasks/epic&quot;, (httpExchange) -&gt; {    // для эпиков — /tasks/epic</b>
<b class="nc">&nbsp;            String method = httpExchange.getRequestMethod();</b>
<b class="nc">&nbsp;            String response = null; //инициализируем сразу, чтобы избежать случая, когда в методе POST данная срока не проинициализируется</b>
<b class="nc">&nbsp;            String epicIdInfo = null;</b>
<b class="nc">&nbsp;            switch (method) {</b>
&nbsp;                case &quot;GET&quot;:
&nbsp;                    //Метод getRawQuery() возвращает строку SQL-запроса, который еще не был скомпилирован.
&nbsp;                    // Этот метод используется для создания запросов, где значения параметров уже включены в сам запрос.
<b class="nc">&nbsp;                    epicIdInfo = httpExchange.getRequestURI().getRawQuery();</b>
<b class="nc">&nbsp;                    if (epicIdInfo != null) {</b>
<b class="nc">&nbsp;                        int epicId = getValueOfId(epicIdInfo);</b>
<b class="nc">&nbsp;                        response = getEpicById(epicId).toString();</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        response = getAllEpics().toString();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    printResponse(response, httpExchange);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case &quot;POST&quot;:
<b class="nc">&nbsp;                    InputStream inputStream = httpExchange.getRequestBody();</b>
<b class="nc">&nbsp;                    String jsonString = new String(inputStream.readAllBytes(), UTF_8);</b>
<b class="nc">&nbsp;                    Epic newEpic = gson.fromJson(jsonString, Epic.class);</b>
<b class="nc">&nbsp;                    if (!epics.containsKey(newEpic.getId())) {</b>
<b class="nc">&nbsp;                        addEpic(newEpic);</b>
<b class="nc">&nbsp;                        response = String.format(&quot;Эпик под id = %d успешно создан&quot;, newEpic.getId());</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        updateEpicById(newEpic.getId(), newEpic);</b>
<b class="nc">&nbsp;                        response = String.format(&quot;Эпик под id = %d успешно обновлен&quot;, newEpic.getId());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    printResponse(response, httpExchange);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case &quot;DELETE&quot;:
<b class="nc">&nbsp;                    epicIdInfo = httpExchange.getRequestURI().getRawQuery();</b>
<b class="nc">&nbsp;                    if (epicIdInfo != null) {</b>
<b class="nc">&nbsp;                        int epicId = getValueOfId(epicIdInfo);</b>
<b class="nc">&nbsp;                        removeEpicById(epicId);</b>
<b class="nc">&nbsp;                        response = String.format(&quot;Эпик под id = %d удален&quot;, epicId);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    printResponse(response, httpExchange);</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private void workingOnSubtasks() {
<b class="fc">&nbsp;        server.createContext(&quot;/tasks/subtask&quot;, (httpExchange) -&gt; { //для подзадач — /tasks/subtask</b>
<b class="nc">&nbsp;            String method = httpExchange.getRequestMethod();</b>
<b class="nc">&nbsp;            String response = null;</b>
<b class="nc">&nbsp;            String subtaskIdInfo = null;</b>
<b class="nc">&nbsp;            switch (method) {</b>
&nbsp;                case &quot;GET&quot;:
<b class="nc">&nbsp;                    subtaskIdInfo = httpExchange.getRequestURI().getRawQuery();</b>
<b class="nc">&nbsp;                    if (subtaskIdInfo != null) {</b>
<b class="nc">&nbsp;                        int subtaskId = getValueOfId(subtaskIdInfo);</b>
<b class="nc">&nbsp;                        response = getSubtaskById(subtaskId).toString();</b>
&nbsp;                    }
&nbsp;                    // Так, а тут мы не можем получить список всех подзадач без id конкретного эпика...
<b class="nc">&nbsp;                    printResponse(response, httpExchange);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case &quot;POST&quot;:
<b class="nc">&nbsp;                    InputStream inputStream = httpExchange.getRequestBody();</b>
<b class="nc">&nbsp;                    String jsonString = new String(inputStream.readAllBytes());</b>
<b class="nc">&nbsp;                    Subtask newSubtask = gson.fromJson(jsonString, Subtask.class);</b>
<b class="nc">&nbsp;                    Epic epic = getEpicById(newSubtask.getEpicId());</b>
<b class="nc">&nbsp;                    if (!subtasks.containsKey(newSubtask.getId())) {</b>
<b class="nc">&nbsp;                        addSubtask(newSubtask, epic); //Нужен эпик, к которому будет привязана эта подзадача...</b>
&nbsp;                        //Эпик указывается при создании продзадачи, следовательно, можно вытащить его из newSubtask
<b class="nc">&nbsp;                        System.out.println(&quot;Подзадача создана&quot;);</b>
<b class="nc">&nbsp;                        response = String.format(&quot;Подзадача под id = %d успешно создана&quot;, newSubtask.getId());</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        updateSubtask(newSubtask.getEpicId(), newSubtask);</b>
<b class="nc">&nbsp;                        response = String.format(&quot;Подзадача под id = %d успешно обновлена&quot;, newSubtask.getId());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case &quot;DELETE&quot;:
<b class="nc">&nbsp;                    subtaskIdInfo = httpExchange.getRequestURI().getRawQuery();</b>
<b class="nc">&nbsp;                    if (subtaskIdInfo != null) {</b>
<b class="nc">&nbsp;                        int subtaskId = getValueOfId(subtaskIdInfo);</b>
<b class="nc">&nbsp;                        removeSubtaskById(subtaskId);</b>
<b class="nc">&nbsp;                        response = String.format(&quot;Подзадача под id = %d удалена&quot;, subtaskId);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    printResponse(response, httpExchange);</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Получить все задачи сразу можно будет по пути /tasks/, а получить историю задач по пути /tasks/history.
&nbsp;     * Так же, пока еще не реализована возможность получения всех подзадач
&nbsp;     */
&nbsp;
&nbsp;    //Получаем все подзадачи эпика. Так как выше, ввиду спецификации подзадач реализовать это возможности не было.
&nbsp;    private void workWithAllSubtasksOfEpic() {               //для подзадач — /tasks/subtask/epic
<b class="fc">&nbsp;        server.createContext(&quot;/tasks/subtask/epic&quot;, (httpExchange) -&gt; {</b>
<b class="nc">&nbsp;            String method = httpExchange.getRequestMethod();</b>
<b class="nc">&nbsp;            String response = null;</b>
<b class="nc">&nbsp;            String epicIdInfo = null;</b>
<b class="nc">&nbsp;            if (method.equals(&quot;GET&quot;)) {</b>
<b class="nc">&nbsp;                epicIdInfo = httpExchange.getRequestURI().getRawQuery();</b>
<b class="nc">&nbsp;                if (epicIdInfo != null) {</b>
<b class="nc">&nbsp;                    int epicId = getValueOfId(epicIdInfo);</b>
<b class="nc">&nbsp;                    response = getAllSubtasksByEpic(epicId).toString();</b>
&nbsp;                }
<b class="nc">&nbsp;                printResponse(response, httpExchange);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private void getAllTasks() {   //Получить все задачи сразу можно будет по пути /tasks/
<b class="fc">&nbsp;        server.createContext(&quot;/tasks&quot;, (httpExchange) -&gt; {</b>
<b class="nc">&nbsp;            String method = httpExchange.getRequestMethod();</b>
<b class="nc">&nbsp;            String response = null;</b>
<b class="nc">&nbsp;            if (method.equals(&quot;GET&quot;)) {</b>
<b class="nc">&nbsp;                response = getPrioritizedTasks().toString();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                response = &quot;Ошибка обработки запроса &quot; + method;</b>
&nbsp;            }
<b class="nc">&nbsp;            printResponse(response, httpExchange);</b>
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private void workingWithHistory() {      // получить историю задач по пути /tasks/history
<b class="fc">&nbsp;        server.createContext(&quot;/tasks/history&quot;, httpExchange -&gt; {</b>
<b class="nc">&nbsp;            String method = httpExchange.getRequestMethod();</b>
<b class="nc">&nbsp;            String response = null;</b>
<b class="nc">&nbsp;            if (method.equals(&quot;GET&quot;)) {</b>
<b class="nc">&nbsp;                response = historyList().toString();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                response = &quot;Ошибка обработки запроса &quot; + method;</b>
&nbsp;            }
<b class="nc">&nbsp;            printResponse(response, httpExchange);</b>
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private int getValueOfId(String infOfId) {          ////Вынесем в отдельный метод, так как используется в коде довольно часто
<b class="nc">&nbsp;        String[] infOfIfSplit = infOfId.split(&quot;=&quot;);</b>
<b class="nc">&nbsp;        return Integer.parseInt(infOfIfSplit[1]);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void printResponse(String response, HttpExchange httpExchange) { //Вынесем в отдельный метод, так как используется в коде довольно часто
&nbsp;        try { // Unhandled exception: java.io.IOException
<b class="nc">&nbsp;            if (response != null) {</b>
<b class="nc">&nbsp;                httpExchange.sendResponseHeaders(200, 0); //Метод отправляет ответ, который можно сформировать заранее.</b>
&nbsp;                //Если вместе с ответом необходимо передать какие-либо данные, нужно получить экземпляр класса OutputStream, связанный с телом ответа.
<b class="nc">&nbsp;                try (OutputStream os = httpExchange.getResponseBody()) { //Необходимо вызвать метод getResponseBody() класса HttpExchange</b>
&nbsp;                    //Класс OutputStream позволяет записывать данные в виде массива байтов. Для этого нужно вызвать метод write(byte b[])
<b class="nc">&nbsp;                    os.write(response.getBytes());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            } else {
<b class="nc">&nbsp;                httpExchange.sendResponseHeaders(400, 0);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            e.getMessage();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-03-14 22:21</div>
</div>
</body>
</html>
