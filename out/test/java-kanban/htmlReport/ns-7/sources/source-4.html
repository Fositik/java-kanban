


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > InMemoryTaskManager</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">ru.yandex.practicum.model</a>
</div>

<h1>Coverage Summary for Class: InMemoryTaskManager (ru.yandex.practicum.model)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">InMemoryTaskManager</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (25/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95,6%
  </span>
  <span class="absValue">
    (130/136)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package ru.yandex.practicum.model;
&nbsp;
&nbsp;import ru.yandex.practicum.service.Epic;
&nbsp;import ru.yandex.practicum.service.Status;
&nbsp;import ru.yandex.practicum.service.Subtask;
&nbsp;import ru.yandex.practicum.service.Task;
&nbsp;
&nbsp;import java.time.LocalDateTime;
&nbsp;import java.util.*;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;//В класс InMemoryTaskManager были перенесены все методы из TaskManager
<b class="fc">&nbsp;public class InMemoryTaskManager implements TaskManager {</b>
&nbsp;    // HistoryManager historyManager = Managers.getDefaultHistory();
<b class="fc">&nbsp;    protected final InMemoryHistoryManager historyManager = new InMemoryHistoryManager();</b>
&nbsp;    //Счетчик для идентификаторов задач
<b class="fc">&nbsp;    private int nextId = 1;</b>
&nbsp;    //хеш-таблица для хранения списка просых задач
<b class="fc">&nbsp;    protected HashMap&lt;Integer, Task&gt; simpleTasks = new HashMap&lt;&gt;();</b>
&nbsp;    //хеш-таблица для хранения списка эпиков
<b class="fc">&nbsp;    protected HashMap&lt;Integer, Epic&gt; epics = new HashMap&lt;&gt;();</b>
&nbsp;    //хеш-таблица для хранения списка подзадач
<b class="fc">&nbsp;    protected HashMap&lt;Integer, Subtask&gt; subtasks = new HashMap&lt;&gt;();</b>
&nbsp;    //TreeSet для хранения отсортированного списка задач по времени
&nbsp;    protected TreeSet&lt;Task&gt; sortedTasks;
&nbsp;
&nbsp;    //public InMemoryTaskManager(HistoryManager historyManager){
&nbsp;//    this.historyManager = h
&nbsp;//}
&nbsp;    @Override
&nbsp;    //метод для добавления простой задачи
&nbsp;    public void addSimpleTask(Task task) {
<b class="fc">&nbsp;        if (simpleTasks.containsKey(task.getId())) {</b>
<b class="fc">&nbsp;            System.out.println(&quot;Такая задача уже существует, её id = &quot; + task.getId());</b>
&nbsp;        } else {
<b class="fc">&nbsp;            task.setId(nextId++);</b>
<b class="fc">&nbsp;            simpleTasks.put(task.getId(), task);</b>
<b class="fc">&nbsp;            isNotIntersection(task);</b>
<b class="fc">&nbsp;            System.out.println(&quot;Задача успешно создана! ID = &quot; + task.getId());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для добавления эпика
&nbsp;    public void addEpic(Epic epic) {
&nbsp;        //   LocalDateTime startTime = null;
<b class="fc">&nbsp;        if (epics.containsKey(epic.getId())) {</b>
<b class="fc">&nbsp;            System.out.println(&quot;Такой эпик уже существует, его id = &quot; + epic.getId());</b>
&nbsp;        } else {
&nbsp;            //задаем уникальный id эпику
<b class="fc">&nbsp;            epic.setId(nextId++);</b>
<b class="fc">&nbsp;            epics.put(epic.getId(), epic);</b>
<b class="fc">&nbsp;            System.out.println(&quot;Эпик успешно создан! ID = &quot; + epic.getId());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для добавления подзадачи
&nbsp;    public void addSubtask(Subtask subtask, Epic epic) {
&nbsp;        //если epicId подзадача совпадает с существующей
<b class="fc">&nbsp;        if (subtasks.containsKey(subtask.getId())) {</b>
<b class="fc">&nbsp;            System.out.println(&quot;Подзадача с id &quot; + subtask.getId() + &quot; уже существует!&quot;);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            subtask.setId(nextId++); //задаем уникальный id подзадаче</b>
&nbsp;            //добавляем подзадачу в список подзадач
<b class="fc">&nbsp;            subtasks.put(subtask.getId(), subtask);</b>
<b class="fc">&nbsp;            subtask.setEpic(epic);</b>
<b class="fc">&nbsp;            isNotIntersection(subtask);</b>
&nbsp;            //Добавляем подзадачу в список SubtasksIds для того, чтобы иметь возможность получать список подзадач эпика
<b class="fc">&nbsp;            epics.get(epic.getId()).getSubtasks().add(subtask);</b>
<b class="fc">&nbsp;            epics.get(epic.getId()).calculateStatrTimeAndDuration();</b>
<b class="fc">&nbsp;            System.out.println(&quot;Подзадача к эпику id = &quot; + subtask.getId() + &quot; успешно создана!&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для получения подзадачи по id
&nbsp;    public Subtask getSubtaskById(int subtaskId) {
&nbsp;        //метод для добавления подзадачи в список истории просмотра
<b class="fc">&nbsp;        historyManager.add(subtasks.get(subtaskId));</b>
<b class="fc">&nbsp;        return subtasks.get(subtaskId);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для получения эпика по id
&nbsp;    public Epic getEpicById(int epicId) {
&nbsp;        //метод для добавления эпика в список истории просмотра
<b class="fc">&nbsp;        historyManager.add(epics.get(epicId));</b>
<b class="fc">&nbsp;        return epics.get(epicId);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для получения задачи по id
&nbsp;    public Task getSimpleTaskById(int simpleTaskId) {
&nbsp;        //метод для добавления задачи в список истории просмотра
<b class="fc">&nbsp;        historyManager.add(simpleTasks.get(simpleTaskId));</b>
<b class="fc">&nbsp;        return simpleTasks.get(simpleTaskId);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для получения списка всех задач
&nbsp;    public ArrayList&lt;Task&gt; getAllSimpleTasks() {
<b class="fc">&nbsp;        return new ArrayList&lt;&gt;(simpleTasks.values());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для получения списка всех эпиков
&nbsp;    public ArrayList&lt;Epic&gt; getAllEpics() {
<b class="fc">&nbsp;        return new ArrayList&lt;&gt;(epics.values());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для получения id подзадач эпика
&nbsp;    public ArrayList&lt;Subtask&gt; getAllSubtasksByEpic(int epicId) {
<b class="fc">&nbsp;        return new ArrayList&lt;&gt;(epics.get(epicId).getSubtasks());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для удаления задачи по id
&nbsp;    public void removeSimbletaskById(int simpleTaskId) {
<b class="fc">&nbsp;        historyManager.remove(simpleTaskId);</b>
<b class="fc">&nbsp;        simpleTasks.remove(simpleTaskId);</b>
<b class="fc">&nbsp;        System.out.println(&quot;Задача под id= &quot; + simpleTaskId + &quot; была успешно удалена!&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для удаления эпика по id--&gt;вместе с эпиковм удаляются все подзадачи
&nbsp;    public void removeEpicById(int epicId) {
<b class="fc">&nbsp;        historyManager.remove(epicId);</b>
<b class="fc">&nbsp;        for (Subtask subtask : epics.get(epicId).getSubtasks()) {</b>
<b class="nc">&nbsp;            historyManager.remove(subtask.getId());</b>
&nbsp;            // subtasks.remove(subtask.getId());
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;        epics.get(epicId).getSubtasks().clear();</b>
<b class="fc">&nbsp;        epics.remove(epicId);</b>
<b class="fc">&nbsp;        System.out.println(&quot;Эпик под id= &quot; + epicId + &quot; и все его подзадачи успешно удалены!&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для удаления подзадачи по id
&nbsp;    public void removeSubtaskById(int subtaskId) {
<b class="fc">&nbsp;        historyManager.remove(subtaskId);</b>
<b class="fc">&nbsp;        epics.get(subtasks.get(subtaskId).getEpic().getId()).getSubtasks().remove(subtasks.get(subtaskId));</b>
<b class="fc">&nbsp;        subtasks.remove(subtaskId);</b>
<b class="fc">&nbsp;        System.out.println(&quot;Подзадача успешно удалена!&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для обновления задачи по id
&nbsp;    public Task updateSimpleTaskById(int taskId, Task task) {
<b class="fc">&nbsp;        if (simpleTasks.containsKey(taskId)) {</b>
<b class="fc">&nbsp;            Task value = simpleTasks.get(taskId);</b>
<b class="fc">&nbsp;            value.setName(task.getName());</b>
<b class="fc">&nbsp;            value.setStatus(task.getStatus());</b>
<b class="fc">&nbsp;            value.setDescription(task.getDescription());</b>
<b class="fc">&nbsp;            isNotIntersection(task);</b>
<b class="fc">&nbsp;            value.setStartTime(task.getStartTime());</b>
<b class="fc">&nbsp;            value.setDuration(task.getDuration());</b>
<b class="fc">&nbsp;            System.out.println(&quot;Задача под id = &quot; + taskId + &quot; успешно обновлена!&quot;);</b>
<b class="fc">&nbsp;            return value;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            System.out.println(&quot;Задачи под id = &quot; + taskId + &quot; не существует!&quot;);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для обновления задачи по id
&nbsp;    public Epic updateEpicById(int taskId, Epic epic) {
<b class="fc">&nbsp;        if (epics.containsKey(taskId)) {</b>
&nbsp;            //id остается прежним
<b class="fc">&nbsp;            Epic value = epics.get(taskId);</b>
<b class="fc">&nbsp;            value.setName(epic.getName());</b>
<b class="fc">&nbsp;            value.setStatus(epic.getStatus());</b>
<b class="fc">&nbsp;            return value;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            System.out.println(&quot;Эпика под id = &quot; + taskId + &quot; не существует!&quot;);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //метод для обновления подзадачи по id
&nbsp;    public Subtask updateSubtask(int taskId, Subtask subtask) {
&nbsp;        //id подзадачи остаётся прежним
<b class="fc">&nbsp;        if (subtasks.containsKey(taskId)) {</b>
&nbsp;            //id эпика тоже остается прежним
<b class="fc">&nbsp;            Subtask value = subtasks.get(taskId);               //id</b>
<b class="fc">&nbsp;            value.getEpic().equals(subtask.getEpic());          //</b>
<b class="fc">&nbsp;            value.setDescription(subtask.getDescription());</b>
<b class="fc">&nbsp;            value.setName(subtask.getName());</b>
<b class="fc">&nbsp;            value.setStatus(subtask.getStatus());</b>
<b class="fc">&nbsp;            isNotIntersection(subtask);</b>
<b class="fc">&nbsp;            value.setStartTime(subtask.getStartTime());</b>
<b class="fc">&nbsp;            value.setDuration(subtask.getDuration());</b>
&nbsp;            //Вызываем метод для проверки статуса эпика на DONE
<b class="fc">&nbsp;            epics.get(value.getEpic().getId()).checkEpicStatusDone();</b>
&nbsp;            //Если статус эпика не IN_PROGRESS, то вызываем метод для проверки на IN_PROGRESS
<b class="fc">&nbsp;            if (!epics.get(value.getEpic().getId()).getStatus().equals(Status.IN_PROGRESS)) {</b>
<b class="fc">&nbsp;                epics.get(value.getEpic().getId()).checkEpicStatusInProgresss();</b>
&nbsp;            }
<b class="fc">&nbsp;            System.out.println(&quot;Подзадача под id = &quot; + taskId + &quot; успешно обновлена!&quot;);</b>
<b class="fc">&nbsp;            return value;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            System.out.println(&quot;Подзадачи под id = &quot; + taskId + &quot; не существует!&quot;);</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    //методs очищают все хеш-таблицы, то есть, удалют все задачи/эпики/подзадачи
&nbsp;    public void removeAllSimpleTasks() {
<b class="fc">&nbsp;        simpleTasks.clear();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void removeAllSubtasks() {
<b class="fc">&nbsp;        List&lt;Integer&gt; subtasksIds = new ArrayList&lt;&gt;(subtasks.keySet());</b>
<b class="fc">&nbsp;        for (Integer subtasksId : subtasksIds) {</b>
<b class="fc">&nbsp;            removeSubtaskById(subtasksId);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void removeAllEpics() {
<b class="fc">&nbsp;        epics.clear();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Отсортируйте все задачи по приоритету — то есть по startTime.
&nbsp;     * Если дата старта не задана, добавьте задачу в конец списка задач, подзадач, отсортированных по startTime.
&nbsp;     * Напишите новый метод getPrioritizedTasks, возвращающий список задач и подзадач в заданном порядке.
&nbsp;     *
&nbsp;     * @return
&nbsp;     */
&nbsp;    //То есть, для начала нам необходимо получить список задач отсортированных по времени (1) - метод getAllTasksWithStartTime
&nbsp;    //Далее, получить список задач, не отсортированных по времени (2) - метод getAllTasksWithoutStartTime
&nbsp;    //Для этого необходимо получить список всех имебщихся задач (3) - метод getAllTasks
&nbsp;    //Далее, написать метод getPrioritizedTasks, который будет сортировать задачи методом compareTo, а так де добавлять список отсортированных по времени задач в начало списка, а не отсортированных - в конец
&nbsp;    private ArrayList&lt;Task&gt; getAllTasks() {             //Метод, который возвращает список всех задач
<b class="fc">&nbsp;        ArrayList&lt;Task&gt; allTasks = new ArrayList&lt;&gt;();   //Эпики в этот список не входят, тк их продолжительность/время старта/время окончания формируется исходя из соответствующих параметров подзадач</b>
<b class="fc">&nbsp;        allTasks.addAll(simpleTasks.values());</b>
<b class="fc">&nbsp;        allTasks.addAll(subtasks.values());</b>
<b class="fc">&nbsp;        return allTasks;</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;Task&gt; getAllTasksWithStartTime() {                 //Получаем список задач со временем старта
<b class="fc">&nbsp;        ArrayList&lt;Task&gt; allTasksWithStartTime = new ArrayList&lt;&gt;();  //Список, который мы будем возвращать</b>
<b class="fc">&nbsp;        ArrayList&lt;Task&gt; allTasks = getAllTasks();</b>
<b class="fc">&nbsp;        for (Task task : allTasks) {                                //Перебираем список всех задач</b>
<b class="fc">&nbsp;            if (task.getStartTime() != null) {                      //Если время старта не null</b>
<b class="fc">&nbsp;                allTasksWithStartTime.add(task);                    //Добавляем в наш список</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return allTasksWithStartTime;</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;Task&gt; getAllTasksWithoutStartTime() {
<b class="fc">&nbsp;        ArrayList&lt;Task&gt; allTasksWithoutStartTime = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        ArrayList&lt;Task&gt; allTasks = getAllTasks();</b>
<b class="fc">&nbsp;        for (Task task : allTasks) {</b>
<b class="fc">&nbsp;            if (task.getStartTime() == null) {</b>
<b class="fc">&nbsp;                allTasksWithoutStartTime.add(task);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return allTasksWithoutStartTime;</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;Task&gt; getPrioritizedTasks() {
<b class="fc">&nbsp;        if (sortedTasks != null &amp;&amp; sortedTasks.size() == getAllTasks().size()) {</b>
<b class="fc">&nbsp;            List&lt;Task&gt; allTask = new ArrayList&lt;&gt;(sortedTasks);</b>
<b class="fc">&nbsp;            allTask.addAll(getAllTasksWithoutStartTime());</b>
<b class="fc">&nbsp;            return allTask;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            List&lt;Task&gt; allTasks = getAllTasksWithStartTime()</b>
<b class="fc">&nbsp;                    .stream()</b>
<b class="fc">&nbsp;                    .sorted(Comparator.comparing(Task::getStartTime))</b>
<b class="fc">&nbsp;                    .collect(Collectors.toList());</b>
<b class="fc">&nbsp;            sortedTasks = new TreeSet&lt;&gt;(Comparator.comparing(Task::getStartTime));</b>
<b class="fc">&nbsp;            sortedTasks.addAll(allTasks);</b>
<b class="fc">&nbsp;            allTasks.addAll(getAllTasksWithoutStartTime());</b>
<b class="fc">&nbsp;            return allTasks;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Подсказка: как искать пересечения за O(1)
&nbsp;     * Пусть все задачи располагаются на сетке с интервалами в 15 минут, а планирование возможно только на год вперёд.
&nbsp;     * В этом случае можно заранее заполнить таблицу, где ключ — это интервал, а значение — объект boolean (свободно время или нет).
&nbsp;     * В итоге для эффективного поиска пересечений достаточно будет проверить, что свободны все 15-минутные интервалы задачи.
&nbsp;     */
&nbsp;    private void isNotIntersection(Task task) {
<b class="fc">&nbsp;        boolean isIntersection = false;</b>
<b class="fc">&nbsp;        for (Task priorityTask : getPrioritizedTasks()) {</b>
&nbsp;            /**
&nbsp;             * Вылетает NullPointerException...разбираемся.
&nbsp;             */
<b class="fc">&nbsp;            if (</b>
<b class="fc">&nbsp;                    !task.equals(priorityTask)</b>
<b class="fc">&nbsp;                            &amp;&amp; task.getStartTime() != null</b>
<b class="fc">&nbsp;                            &amp;&amp; priorityTask.getEndTime() != null</b>
<b class="fc">&nbsp;                            &amp;&amp; (task.getStartTime().equals(priorityTask.getEndTime())</b>
<b class="fc">&nbsp;                            || task.getStartTime().isBefore(priorityTask.getEndTime()))</b>
&nbsp;            ) {
<b class="fc">&nbsp;                isIntersection = true;</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        if (isIntersection) {</b>
<b class="fc">&nbsp;            System.out.println(&quot;Пересечение задачи под id = &quot; + task.getId());</b>
<b class="fc">&nbsp;            sortedTasks.remove(task);</b>
<b class="fc">&nbsp;            task.resetStartTimeAndDuration();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //Понадобилось, чтобы в одном из тестов вывести историю просмотров задач
&nbsp;    public List&lt;Task&gt; historyList() {
<b class="fc">&nbsp;        return historyManager.getHistory();</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-03-14 22:21</div>
</div>
</body>
</html>
